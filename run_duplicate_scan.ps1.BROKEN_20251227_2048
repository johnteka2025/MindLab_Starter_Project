# run_duplicate_scan.ps1
# MindLab - Duplicate Scan (Parsing-safe, documentation-safe)

Set-StrictMode -Version Latest
$ErrorActionPreference = 'Stop'

# -----------------------------
# Config
# -----------------------------
$root = 'C:\Projects\MindLab_Starter_Project'

# Default exclusions = keep the DAILY gate focused on "live" project files
$defaultExcludeDirNames = @(
  'node_modules',
  'backups',
  '_snapshots',
  '_quarantine',
  'dist',
  'build',
  '.git'
)

param(
  [switch]$IncludeArchives,     # if set, includes backups/_snapshots/_quarantine in scan
  [switch]$IncludeNodeModules   # if set, includes node_modules in scan (usually NOT desired)
)

# -----------------------------
# Helpers
# -----------------------------
function Assert-Path([string]$p, [string]$label) {
  if (-not (Test-Path -LiteralPath $p)) {
    throw "Missing required path ($label): $p"
  }
}

function Get-ParserErrors([string]$filePath) {
  $tokens = $null
  $errors = $null
  [System.Management.Automation.Language.Parser]::ParseFile($filePath, [ref]$tokens, [ref]$errors) | Out-Null
  return $errors
}

# -----------------------------
# Pre-flight checks (Golden Rules)
# -----------------------------
Assert-Path $root 'ProjectRoot'

# Parser check on THIS script before we do anything else
$thisScript = $MyInvocation.MyCommand.Path
$parseErrors = Get-ParserErrors $thisScript
if ($parseErrors.Count -gt 0) {
  $msg = ($parseErrors | ForEach-Object { $_.Message }) -join "`n"
  throw "PowerShell parser errors detected in $thisScript:`n$msg"
}

$startLocation = Get-Location

try {
  Set-Location -LiteralPath $root

  # Documentation folder
  $docPath = Join-Path -Path $root -ChildPath 'daily_closeout_docs'
  New-Item -ItemType Directory -Force -Path $docPath | Out-Null

  $date = Get-Date -Format 'yyyy-MM-dd'
  $mode = @()
  if ($IncludeArchives) { $mode += 'IncludeArchives' } else { $mode += 'LiveOnly' }
  if ($IncludeNodeModules) { $mode += 'IncludeNodeModules' } else { $mode += 'NoNodeModules' }
  $modeTag = ($mode -join '_')

  $outFile = Join-Path -Path $docPath -ChildPath ("Duplicate_Scan_Result_{0}_{1}.txt" -f $date, $modeTag)

  # Build exclusion set based on parameters
  $exclude = New-Object System.Collections.Generic.HashSet[string]([StringComparer]::OrdinalIgnoreCase)
  foreach ($d in $defaultExcludeDirNames) { [void]$exclude.Add($d) }

  if ($IncludeArchives) {
    # remove archive-related exclusions
    [void]$exclude.Remove('backups')
    [void]$exclude.Remove('_snapshots')
    [void]$exclude.Remove('_quarantine')
  }
  if ($IncludeNodeModules) {
    [void]$exclude.Remove('node_modules')
  }

  # Write header
  "MindLab Duplicate File Scan" | Out-File -FilePath $outFile -Encoding UTF8
  ("Date: {0}" -f (Get-Date))   | Out-File -FilePath $outFile -Append -Encoding UTF8
  ("Project Root: {0}" -f $root) | Out-File -FilePath $outFile -Append -Encoding UTF8
  ("Mode: {0}" -f $modeTag)     | Out-File -FilePath $outFile -Append -Encoding UTF8
  "------------------------------------------------------------" | Out-File -FilePath $outFile -Append -Encoding UTF8

  # Enumerate files while excluding directories by name (parsing-safe, no -join tricks)
  $files =
    Get-ChildItem -LiteralPath $root -Recurse -File -Force -ErrorAction Stop |
    Where-Object {
      # If any directory in the path matches an excluded name, skip it
      $dir = $_.Directory
      while ($null -ne $dir) {
        if ($exclude.Contains($dir.Name)) { return $false }
        $dir = $dir.Parent
      }
      return $true
    }

  $duplicates =
    $files |
    Group-Object -Property Name |
    Where-Object { $_.Count -gt 1 } |
    Sort-Object -Property Count -Descending

  if ($duplicates.Count -eq 0) {
    "RESULT: âœ… NO DUPLICATE FILES FOUND (in selected mode)" | Out-File -FilePath $outFile -Append -Encoding UTF8
  }
  else {
    foreach ($group in $duplicates) {
      "" | Out-File -FilePath $outFile -Append -Encoding UTF8
      ("DUPLICATE FILE NAME: {0}" -f $group.Name) | Out-File -FilePath $outFile -Append -Encoding UTF8
      ("COUNT: {0}" -f $group.Count) | Out-File -FilePath $outFile -Append -Encoding UTF8
      "LOCATIONS:" | Out-File -FilePath $outFile -Append -Encoding UTF8
      foreach ($f in $group.Group) {
        ("  - {0}" -f $f.FullName) | Out-File -FilePath $outFile -Append -Encoding UTF8
      }
    }
  }

  "------------------------------------------------------------" | Out-File -FilePath $outFile -Append -Encoding UTF8
  "END OF SCAN" | Out-File -FilePath $outFile -Append -Encoding UTF8

  # Open for immediate review
  notepad $outFile

  # Console summary
  Write-Host ""
  Write-Host ("Wrote scan results to: {0}" -f $outFile)
  Write-Host ("Duplicate groups found: {0}" -f $duplicates.Count)
}
finally {
  Set-Location -LiteralPath $startLocation
}
