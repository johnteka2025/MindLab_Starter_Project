const fs = require("fs");
const path = require("path");

function safeJsonParse(text) {
  try { return JSON.parse(text); } catch { return null; }
}

function ensureDir(p) {
  if (!fs.existsSync(p)) fs.mkdirSync(p, { recursive: true });
}

function pick(obj, key, fallback) {
  return Object.prototype.hasOwnProperty.call(obj, key) ? obj[key] : fallback;
}

function normalizeLoadedState(raw) {
  const o = (raw && typeof raw === "object") ? raw : {};
  // Keep only known keys; allow future keys safely
  const out = {
    total: typeof o.total === "number" ? o.total : 0,
    solved: typeof o.solved === "number" ? o.solved : 0,
    solvedToday: typeof o.solvedToday === "number" ? o.solvedToday : 0,
    totalSolved: typeof o.totalSolved === "number" ? o.totalSolved : 0,
    streak: typeof o.streak === "number" ? o.streak : 0,
    solvedIds: Array.isArray(o.solvedIds) ? o.solvedIds : [],
    solvedPuzzleIds: (o.solvedPuzzleIds && typeof o.solvedPuzzleIds === "object") ? o.solvedPuzzleIds : {}
  };
  return out;
}

function deepProxy(target, onChange, seen = new WeakMap()) {
  if (!target || typeof target !== "object") return target;
  if (seen.has(target)) return seen.get(target);

  const proxied = new Proxy(target, {
    get(obj, prop) {
      const val = obj[prop];
      // Proxy nested objects/arrays too
      return deepProxy(val, onChange, seen);
    },
    set(obj, prop, value) {
      obj[prop] = value;
      onChange();
      return true;
    },
    deleteProperty(obj, prop) {
      delete obj[prop];
      onChange();
      return true;
    }
  });

  seen.set(target, proxied);
  return proxied;
}

module.exports = function initProgressPersistence(options = {}) {
  const dataFile = options.dataFile || path.join(__dirname, "data", "progress.json");
  ensureDir(path.dirname(dataFile));

  // If progress store doesn't exist yet, nothing to do.
  if (!globalThis.__mindlabProgress) {
    console.warn("[progressPersistence] globalThis.__mindlabProgress not found (yet).");
    return;
  }

  // Load saved state (merge into existing store)
  if (fs.existsSync(dataFile)) {
    const raw = safeJsonParse(fs.readFileSync(dataFile, "utf8"));
    const loaded = normalizeLoadedState(raw);

    const p = globalThis.__mindlabProgress;

    // Merge carefully: keep runtime object identity, update fields
    p.total = loaded.total || p.total || 0;
    p.solved = loaded.solved || 0;
    p.solvedToday = loaded.solvedToday || 0;
    p.totalSolved = loaded.totalSolved || 0;
    p.streak = loaded.streak || 0;

    // solvedIds array + solvedPuzzleIds map
    p.solvedIds = Array.isArray(loaded.solvedIds) ? loaded.solvedIds.slice() : (p.solvedIds || []);
    p.solvedPuzzleIds = (loaded.solvedPuzzleIds && typeof loaded.solvedPuzzleIds === "object")
      ? { ...loaded.solvedPuzzleIds }
      : (p.solvedPuzzleIds || {});
  }

  let saveTimer = null;
  function saveNow() {
    try {
      const p = globalThis.__mindlabProgress || {};
      const snapshot = {
        total: p.total || 0,
        solved: p.solved || 0,
        solvedToday: p.solvedToday || 0,
        totalSolved: p.totalSolved || 0,
        streak: p.streak || 0,
        solvedIds: Array.isArray(p.solvedIds) ? p.solvedIds : [],
        solvedPuzzleIds: (p.solvedPuzzleIds && typeof p.solvedPuzzleIds === "object") ? p.solvedPuzzleIds : {}
      };

      const tmp = dataFile + ".tmp";
      fs.writeFileSync(tmp, JSON.stringify(snapshot, null, 2) + "\n", "utf8");
      fs.renameSync(tmp, dataFile);
    } catch (e) {
      console.warn("[progressPersistence] save failed:", String(e));
    }
  }

  function scheduleSave() {
    if (saveTimer) clearTimeout(saveTimer);
    saveTimer = setTimeout(saveNow, 50);
  }

  // Wrap progress object so ANY mutation triggers save (including nested keys)
  globalThis.__mindlabProgress = deepProxy(globalThis.__mindlabProgress, scheduleSave);

  // Save once after init to ensure file exists
  saveNow();

  // Save on exit
  process.on("SIGINT", () => { saveNow(); process.exit(0); });
  process.on("SIGTERM", () => { saveNow(); process.exit(0); });
  process.on("exit", () => { saveNow(); });

  console.log("[progressPersistence] enabled:", dataFile);
};
